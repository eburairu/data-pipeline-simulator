---
name: speckit-analyze
description: spec.md、plan.md、tasks.md 間の一貫性と品質を非破壊的に分析します。タスク生成後に実行します。
---

## ユーザー入力

```text
$ARGUMENTS
```

ユーザー入力がある場合、処理を進める前に**必ず**考慮してください。

## 目標

実装を開始する前に、3つのコアアーティファクト（`spec.md`, `plan.md`, `tasks.md`）間の矛盾、重複、曖昧さ、および仕様不足を特定します。このコマンドは `/speckit.tasks` が完全な `tasks.md` を生成した後にのみ実行する必要があります。

## 運用上の制約

**完全読み取り専用 (STRICTLY READ-ONLY)**: ファイルを**一切変更しないでください**。構造化された分析レポートを出力します。修正プランの提案は可能ですが、ユーザーが明示的に承認しない限り、自動的に編集コマンドを実行してはいけません。

**プロジェクト原則（Constitution）の権威**: プロジェクト原則（`.specify/memory/constitution.md`）は、この分析範囲内において**交渉の余地はありません**。原則との競合は自動的に「CRITICAL（重大）」な問題とみなされ、原則を薄めたり無視したりするのではなく、仕様、計画、またはタスクの調整が必要です。原則自体を変更する必要がある場合は、`/speckit.analyze` の外で別途、明示的な原則更新を行う必要があります。

## 実行手順

### 1. 分析コンテキストの初期化

リポジトリルートから `.specify/scripts/bash/check-prerequisites.sh --json --require-tasks --include-tasks` を一度実行し、JSONを解析して `FEATURE_DIR` と `AVAILABLE_DOCS` を取得します。絶対パスを導出します：

- SPEC = FEATURE_DIR/spec.md
- PLAN = FEATURE_DIR/plan.md
- TASKS = FEATURE_DIR/tasks.md

必要なファイルが欠けている場合はエラーメッセージを表示して中止します（不足している前提コマンドを実行するようユーザーに指示してください）。
"I'm Groot" のような引数内のシングルクォートについては、エスケープ構文を使用してください：例 'I'\''m Groot'（または可能ならダブルクォート："I'm Groot"）。

### 2. アーティファクトの読み込み（段階的開示）

各アーティファクトから必要最小限のコンテキストのみを読み込みます：

**spec.md から:**

- 概要/コンテキスト (Overview/Context)
- 機能要件 (Functional Requirements)
- 非機能要件 (Non-Functional Requirements)
- ユーザーストーリー (User Stories)
- エッジケース (Edge Cases) ※存在する場合

**plan.md から:**

- アーキテクチャ/スタックの選択
- データモデル参照
- フェーズ (Phases)
- 技術的制約 (Technical constraints)

**tasks.md から:**

- タスクID
- 説明 (Descriptions)
- フェーズのグループ化
- 並行マーカー [P]
- 参照ファイルパス

**constitution から:**

- `.specify/memory/constitution.md` を読み込み、原則の検証に使用します。

### 3. セマンティックモデルの構築

内部表現を作成します（生のアーティファクトを出力に含めないでください）：

- **要件インベントリ**: 各機能/非機能要件に安定したキーを付与（命令形のフレーズに基づくスラッグを導出、例: "User can upload file" → `user-can-upload-file`）
- **ユーザーストーリー/アクションインベントリ**: 個別のユーザーアクションと受け入れ基準
- **タスクカバレッジマッピング**: 各タスクを1つ以上の要件またはストーリーにマッピング（キーワードやID、キーフレーズによる推論）
- **原則ルールセット**: 原則名と「MUST（必須）/SHOULD（推奨）」の規範的な記述を抽出

### 4. 検出パス（トークン効率の良い分析）

シグナルの高い発見に焦点を当てます。発見事項は合計50件に制限し、残りはオーバーフローサマリーとして集約します。

#### A. 重複検出

- ほぼ重複している要件を特定
- 統合すべき低品質な言い回しをマーク

#### B. 曖昧さ検出

- 測定可能な基準を欠く曖昧な表現（fast, scalable, secure, intuitive, robust）にフラグを立てる
- 未解決のプレースホルダー（TODO, TKTK, ???, `<placeholder>` など）にフラグを立てる

#### C. 仕様不足 (Underspecification)

- 動詞はあるが目的語や測定可能な結果が欠けている要件
- 受け入れ基準との整合性が欠けているユーザーストーリー
- spec/plan で定義されていないファイルやコンポーネントを参照しているタスク

#### D. 原則（Constitution）との整合性

- 「MUST」原則と競合する要件または計画要素
- 原則で義務付けられたセクションや品質ゲートの欠落

#### E. カバレッジギャップ

- 関連するタスクがゼロの要件
- 要件/ストーリーにマッピングされていないタスク
- タスクに反映されていない非機能要件（パフォーマンス、セキュリティなど）

#### F. 不整合 (Inconsistency)

- 用語の揺れ（同じ概念がファイル間で異なる名前で呼ばれている）
- plan で参照されているが spec に存在しないデータエンティティ（またはその逆）
- タスク順序の矛盾（例：依存関係の注記なしに、基盤セットアップタスクの前に統合タスクがある）
- 競合する要件（例：一方が Next.js を要求し、他方が Vue を指定している）

### 5. 重要度（Severity）の割り当て

以下のヒューリスティックを使用して優先順位を付けます：

- **CRITICAL**: 原則の「MUST」違反、コア仕様アーティファクトの欠落、または基本機能をブロックするカバレッジゼロの要件
- **HIGH**: 重複または競合する要件、曖昧なセキュリティ/パフォーマンス属性、テスト不可能な受け入れ基準
- **MEDIUM**: 用語の揺れ、非機能タスクのカバレッジ欠落、仕様不足のエッジケース
- **LOW**: スタイル/言い回しの改善、実行順序に影響しない軽微な冗長性

### 6. コンパクトな分析レポートの作成

以下の構造を持つMarkdownレポートを出力します（ファイルの書き込みは行いません）：

## Specification Analysis Report

| ID | Category | Severity | Location(s) | Summary | Recommendation |
|----|----------|----------|-------------|---------|----------------|
| A1 | Duplication | HIGH | spec.md:L120-134 | Two similar requirements ... | Merge phrasing; keep clearer version |

（発見ごとに1行追加し、カテゴリの頭文字をプレフィックスとした安定したIDを生成します。）

**Coverage Summary Table:**

| Requirement Key | Has Task? | Task IDs | Notes |
|-----------------|-----------|----------|-------|

**Constitution Alignment Issues:** (if any)

**Unmapped Tasks:** (if any)

**Metrics:**

- Total Requirements
- Total Tasks
- Coverage % (requirements with >=1 task)
- Ambiguity Count
- Duplication Count
- Critical Issues Count

### 7. 次のアクションの提示

レポートの最後に、簡潔な Next Actions ブロックを出力します：

- **CRITICAL** な問題がある場合：`/speckit.implement` の前に解決することを推奨
- **LOW/MEDIUM** のみの場合：進めても良いが、改善提案を提示
- 具体的なコマンド提案を行う：例：「`/speckit.specify` を実行して詳細化」、「`/speckit.plan` を実行してアーキテクチャを調整」、「tasks.md を手動編集して 'performance-metrics' のカバレッジを追加」

### 8. 修正の提案 (Remediation)

ユーザーに次のように尋ねます：「上位N件の問題について、具体的な修正案を提示しましょうか？（自動適用はしません）」

## 運用原則

### コンテキスト効率

- **高シグナル・最小トークン**: 網羅的なドキュメントではなく、アクション可能な発見に焦点を当てる
- **段階的開示**: アーティファクトを増分的に読み込み、すべてのコンテンツを分析にダンプしない
- **トークン効率の良い出力**: 発見テーブルを50行に制限し、オーバーフローを要約する
- **決定論的結果**: 変更なしで再実行した場合、一貫したIDとカウントを生成する

### 分析ガイドライン

- **ファイルを絶対に変更しない**（読み取り専用分析）
- **欠落セクションを幻覚しない**（不在の場合は正確に報告する）
- **原則違反を優先する**（これらは常に CRITICAL）
- **包括的なルールより具体例を使用する**（一般的なパターンではなく特定のインスタンスを引用）
- **問題ゼロを優雅に報告する**（カバレッジ統計を含む成功レポートを出力）

## コンテキスト

$ARGUMENTS
