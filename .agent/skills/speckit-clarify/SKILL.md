---
name: speckit-clarify
description: 現在の機能仕様における不明確な領域を特定し、最大5つのターゲットを絞った明確化の質問を行い、回答を仕様書に直接反映させます。
---

## ユーザー入力

```text
$ARGUMENTS
```

ユーザー入力がある場合、処理を進める前に**必ず**考慮してください。

## 概要

目標：アクティブな機能仕様における曖昧さや欠落している決定ポイントを検出し減らすこと。明確化された内容は直接仕様ファイルに記録します。

注意：この明確化ワークフローは、`/speckit.plan` を呼び出す**前**に実行（および完了）されることが期待されています。ユーザーが明確化のスキップを明示した場合（例：探索的スパイク）は進めても構いませんが、下流での手戻りリスクが増加することを警告する必要があります。

## 実行手順

### 1. 前提条件チェック

リポジトリルートから `.specify/scripts/bash/check-prerequisites.sh --json --paths-only` を**一度**実行します。最小限のJSONペイロードフィールドを解析します：
- `FEATURE_DIR`
- `FEATURE_SPEC`
- （将来の連鎖フローのために `IMPL_PLAN`, `TASKS` をオプションでキャプチャ）

JSON解析に失敗した場合は中止し、ユーザーに `/speckit.specify` の再実行または機能ブランチ環境の検証を指示してください。

### 2. 現行仕様の読み込みとスキャン

現在の仕様ファイルを読み込みます。以下の分類法を使用して、構造化された曖昧さとカバレッジのスキャンを実行します。各カテゴリについて、ステータス（Clear / Partial / Missing）をマークし、優先順位付けに使用する内部カバレッジマップを作成します（質問を行わない場合を除き、生のマップは出力しないでください）。

- **機能スコープと動作**: コアユーザーゴール、明示的なスコープ外宣言、ユーザーロール/ペルソナ
- **ドメインとデータモデル**: エンティティ/属性/リレーション、識別/一意性ルール、ライフサイクル/状態遷移、データ量/スケール想定
- **インタラクションとUXフロー**: クリティカルユーザージャーニー、エラー/空/ロード状態、アクセシビリティ/ローカライズ
- **非機能品質属性**: パフォーマンス（レイテンシ等）、スケーラビリティ、信頼性/可用性、可観測性（ログ/メトリクス）、セキュリティ/プライバシー、コンプライアンス
- **統合と外部依存**: 外部サービス/APIと失敗モード、インポート/エクスポート形式、プロトコル/バージョニング
- **エッジケースと失敗処理**: ネガティブシナリオ、レート制限、競合解決
- **制約とトレードオフ**: 技術的制約、明示的なトレードオフ
- **用語と一貫性**: 用語集、非推奨用語の回避
- **完了シグナル**: 受け入れ基準のテスト容易性、DoD指標
- **その他/プレースホルダー**: TODOマーカー、未解決の決定事項、定量化されていない曖昧な形容詞

Partial または Missing ステータスのカテゴリごとに、以下の場合を除き、候補となる質問機会を追加します：
- 明確化が実装や検証戦略を実質的に変更しない場合
- 情報が計画フェーズまで延期した方が良い場合（内部的にメモする）

### 3. 質問キューの生成

優先順位付けされた明確化質問のキュー（最大5つ）を（内部的に）生成します。一度にすべて出力しないでください。以下の制約を適用します：

- セッション全体で合計10問まで。
- 各質問は以下のいずれかで回答可能である必要があります：
    - 短い選択肢（2〜5個の明確で相互排他的なオプション）
    - 単語/短いフレーズの回答（「5単語以内で回答してください」と明示的に制約）
- アーキテクチャ、データモデリング、タスク分解、テスト設計、UX動作、運用準備、またはコンプライアンス検証に実質的な影響を与える質問のみを含めます。
- インパクトと不確実性のヒューリスティックに基づいて上位5つを選択します。すでに回答された質問や些細な文言の好みは除外します。

### 4. 順次質問ループ（インタラクティブ）

**一度に正確に1つの質問**を提示します。

**選択式の質問の場合**:
- すべてのオプションを分析し、ベストプラクティスやプロジェクトの目標に基づいて**最も適切なオプション**を決定します。
- **推奨オプションを目立つように**上部に提示し、明確な理由を述べます。
- その後、すべてのオプションをMarkdownテーブルとしてレンダリングします：
  | Option | Description |
  |--------|-------------|
  | A | ... |
  | B | ... |
- 「オプションの記号（例："A"）で返信するか、推奨を受け入れる場合は "yes" または "recommended"、独自の短い回答を提供してください」と追記します。

**短答式の質問の場合**:
- ベストプラクティスに基づいた**提案回答**を提示します。
- その後、「フォーマット：短い回答（5単語以内）。提案を受け入れる場合は "yes" または "suggested"、独自の回答を提供してください」と出力します。

**ユーザー回答後**:
- "yes" などの場合、推奨/提案された回答を使用します。
- それ以外の場合、回答がオプションに対応するか、制約を満たすか検証します。
- 曖昧な場合は簡単な明確化を求めます（同じ質問としてカウント）。
- 満足できれば、作業メモリに記録し（まだディスクには書き込まない）、次の質問へ進みます。

**終了条件**:
- すべての重要な曖昧さが早期に解決された場合
- ユーザーが完了のシグナル（"done", "good", "no more"）を送った場合
- 5つの質問に達した場合

### 5. 統合（各回答承認後）

- スペックのインメモリ表現と生ファイルの内容を維持します。
- このセッションでの最初の統合回答の場合：
    - `## Clarifications` セクションが存在することを確認します（なければ作成）。
    - その下に `### Session YYYY-MM-DD` サブヘッディングを作成します。
- 承認直後に箇条書きを追加します：`- Q: <question> → A: <final answer>`。
- その後、**即座に**明確化内容を最も適切なセクションに適用します：
    - 機能の曖昧さ → 機能要件を更新または追加
    - ユーザーインタラクション → ユーザーストーリーを更新
    - データ形状 → データモデルを更新
    - 非機能制約 → 品質属性セクションに測定可能な基準を追加
    - エッジケース → エッジケース/エラー処理に箇条書きを追加
    - 用語の競合 → 用語を統一
- 以前の曖昧な記述を無効にする場合は、重複させずに置換します。
- コンテキスト損失のリスクを最小限に抑えるため、**各統合後にスペックファイルを保存**します（アトミック上書き）。

### 6. 検証

- 各セッションには、承認された回答ごとに正確に1つの箇条書きがあること。
- 質問数は合計5つ以下。
- 更新されたセクションに、解決されたはずの曖昧なプレースホルダーが残っていないこと。
- Markdown構造が有効であること。
- 用語が一貫していること。

### 7. スペック書き込み

更新されたスペックを `FEATURE_SPEC` に書き込みます。

### 8. 完了報告

- 質問と回答の数
- 更新されたスペックのパス
- 更新されたセクション名
- カバレッジサマリーテーブル（Status: Resolved, Deferred, Clear, Outstanding）
- 残りの Outstanding または Deferred 項目の有無に応じた次のステップの推奨

## 行動ルール

- 重要な曖昧さが見つからない場合は、「正式な明確化に値する重要な曖昧さは検出されませんでした」と回答し、進めることを提案します。
- スペックファイルがない場合は、まず `/speckit.specify` を実行するよう指示します。
- 合計5問を超えないでください。
- 機能の明確さをブロックしない限り、推測的な技術スタックの質問は避けてください。
- ユーザーの早期終了シグナルを尊重してください。

## 優先順位付けのためのコンテキスト

$ARGUMENTS
