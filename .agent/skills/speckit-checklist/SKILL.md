---
name: speckit-checklist
description: ユーザー要件に基づいて、現在の機能のカスタムチェックリストを生成します。
---

## チェックリストの目的：「英語（要件）のユニットテスト」

**重要な概念**: チェックリストは**要件記述のためのユニットテスト**です。特定のドメインにおける要件の品質、明確さ、完全性を検証します。

**検証/テスト用ではありません（実装のテストではない）**:

- ❌ 「ボタンが正しくクリックできるか確認する」ではありません
- ❌ 「エラー処理が機能するかテストする」ではありません
- ❌ 「APIが200を返すか確認する」ではありません
- ❌ コード/実装が仕様と一致するかを確認するものではありません

**要件品質の検証用です**:

- ✅ 「すべてのカードタイプについて、視覚的な階層要件が定義されているか？」（完全性）
- ✅ 「『目立つ表示』は具体的なサイズ/配置で定量化されているか？」（明確性）
- ✅ 「ホバー状態の要件は、すべてのインタラクティブ要素で一貫しているか？」（一貫性）
- ✅ 「キーボード操作のアクセシビリティ要件が定義されているか？」（網羅性）
- ✅ 「ロゴ画像の読み込みに失敗した場合の挙動を仕様で定義しているか？」（エッジケース）

**メタファー**: もし仕様書が日本語（自然言語）で書かれたコードだとしたら、チェックリストはそのユニットテストスイートです。実装が機能するかどうかではなく、要件が適切に記述され、完全で、曖昧さがなく、実装の準備ができているかどうかをテストします。

## ユーザー入力

```text
$ARGUMENTS
```

ユーザー入力がある場合、処理を進める前に**必ず**考慮してください。

## 実行手順

### 1. セットアップ

リポジトリルートから `.specify/scripts/bash/check-prerequisites.sh --json` を実行し、JSONを解析して `FEATURE_DIR` と `AVAILABLE_DOCS` リストを取得します。
- すべてのファイルパスは絶対パスである必要があります。
- "I'm Groot" のような引数内のシングルクォートについては、エスケープ構文を使用してください。

### 2. 意図の明確化 (動的)

最大3つの初期コンテキスト確認質問を導出します（事前に用意されたカタログではありません）。これらは以下の条件を満たす必要があります：

- ユーザーの言い回し + spec/plan/tasks から抽出されたシグナルから生成される
- チェックリストの内容を実質的に変更する情報についてのみ質問する
- `$ARGUMENTS` で既に明確な場合はスキップする
- 広範さよりも正確さを優先する

**生成アルゴリズム**:
1. シグナル抽出：機能ドメインのキーワード（auth, latency, UX, APIなど）、リスク指標（"critical", "must", "compliance"）、ステークホルダーのヒント（"QA", "review", security team"）、明示的な成果物（"a11y", "rollback", "contracts"）。
2. シグナルを候補となるフォーカス領域（最大4つ）にクラスタリングし、関連性でランク付けする。
3. 明示的でない場合、想定されるオーディエンスとタイミング（作成者、レビュアー、QA、リリース）を特定する。
4. 欠落している次元を検出する：スコープの広さ、深さ/厳格さ、リスクの強調、除外境界、測定可能な受け入れ基準。
5. 以下のアーキタイプから質問を作成する：
    - スコープの調整（例：「これはXとYとの統合タッチポイントを含めるべきか、それともローカルモジュールの正当性に限定すべきか？」）
    - リスクの優先順位付け（例：「これらの潜在的なリスク領域のうち、どれを必須のゲートチェックとするべきか？」）
    - 深さの調整（例：「これは軽量なコミット前サニティリストなのか、正式なリリースゲートなのか？」）
    - オーディエンスの枠組み（例：「これは作成者のみが使用するのか、PRレビュー中にピアが使用するのか？」）
    - 境界の除外（例：「今回はパフォーマンスチューニングの項目を明示的に除外すべきか？」）
    - シナリオクラスのギャップ（例：「リカバリフローが検出されませんでした。ロールバック/部分的な失敗パスはスコープ内ですか？」）

**質問のフォーマットルール**:
- 選択肢を提示する場合は、カラムを持つコンパクトなテーブルを作成します：Option | Candidate | Why It Matters
- 最大A〜Eのオプションに制限します。自由形式の回答の方が明確な場合はテーブルを省略します。
- ユーザーがすでに言ったことを再確認させないでください。
- 推測的なカテゴリを避けてください（幻覚を見ないこと）。不確かな場合は、「Xがスコープに含まれるか確認してください」と明示的に尋ねます。

**対話不可能な場合のデフォルト**:
- 深さ: 標準
- オーディエンス: コード関連ならレビュアー(PR)、そうでなければ作成者
- フォーカス: 上位2つの関連クラスター

質問を出力します（Q1/Q2/Q3とラベル付け）。回答後、もし2つ以上のシナリオクラス（代替/例外/リカバリ/非機能ドメイン）が不明確なままであれば、最大2つのターゲットを絞ったフォローアップ質問（Q4/Q5）を1行の正当化とともに尋ねてもよいです。合計5つの質問を超えないでください。ユーザーがそれ以上を拒否した場合はエスカレーションをスキップします。

### 3. ユーザーリクエストの理解

`$ARGUMENTS` + 明確化への回答を組み合わせます：
- チェックリストのテーマを導出（例：セキュリティ、レビュー、デプロイ、UX）
- ユーザーが言及した明示的な必須項目を統合
- フォーカス選択をカテゴリの足場にマッピング
- spec/plan/tasks から欠落しているコンテキストを推測（幻覚を見ないこと）

### 4. 機能コンテキストの読み込み

`FEATURE_DIR` から読み込みます：
- spec.md: 機能要件とスコープ
- plan.md (存在する場合): 技術詳細、依存関係
- tasks.md (存在する場合): 実装タスク

**コンテキスト読み込み戦略**:
- アクティブなフォーカス領域に関連する必要な部分のみを読み込む（ファイル全体のダンプを避ける）
- 長いセクションは簡潔なシナリオ/要件の箇条書きに要約することを優先する
- 段階的開示を使用：ギャップが検出された場合にのみ追加の取得を行う
- ソースドキュメントが大きい場合は、生のテキストを埋め込むのではなく、中間サマリー項目を生成する

### 5. チェックリストの生成 - 「要件のユニットテスト」を作成

- まだ存在しない場合は `FEATURE_DIR/checklists/` ディレクトリを作成する
- ユニークなチェックリストファイル名を生成する：
    - ドメインに基づいた短く説明的な名前を使用（例：`ux.md`, `api.md`, `security.md`）
    - フォーマット: `[domain].md`
    - ファイルが存在する場合は、既存のファイルに追加する
- CHK001から順に項目に番号を付ける
- `/speckit.checklist` を実行するたびに新しいファイルを作成する（既存のチェックリストを上書きしない）

**コア原則 - 実装ではなく要件をテストする**:
すべてのチェックリスト項目は、以下の点について**要件そのもの**を評価しなければなりません：
- **完全性 (Completeness)**: 必要な要件はすべて存在するか？
- **明確性 (Clarity)**: 要件は曖昧さがなく具体的か？
- **一貫性 (Consistency)**: 要件同士が整合しているか？
- **測定可能性 (Measurability)**: 要件は客観的に検証可能か？
- **網羅性 (Coverage)**: すべてのシナリオ/エッジケースが扱われているか？

**カテゴリ構造** - 要件品質の次元で項目をグループ化：
- **要件の完全性**（必要な要件はすべて文書化されているか？）
- **要件の明確性**（要件は具体的で曖昧さがないか？）
- **要件の一貫性**（要件に矛盾はないか？）
- **受け入れ基準の品質**（成功基準は測定可能か？）
- **シナリオ網羅性**（すべてのフロー/ケースが扱われているか？）
- **エッジケース網羅性**（境界条件は定義されているか？）
- **非機能要件**（パフォーマンス、セキュリティ、アクセシビリティなどは指定されているか？）
- **依存関係と前提**（それらは文書化され検証されているか？）
- **曖昧さと競合**（何を明確にする必要があるか？）

**チェックリスト項目の書き方 - 「日本語（要件）のユニットテスト」**:

❌ **間違い**（実装のテスト）:
- 「ランディングページに3つのエピソードカードが表示されることを確認する」
- 「デスクトップでホバー状態が機能することをテストする」
- 「ロゴをクリックするとホームに遷移することを確認する」

✅ **正解**（要件品質のテスト）:
- 「特集エピソードの正確な数とレイアウトは指定されているか？ [完全性]」
- 「『目立つ表示』は具体的なサイズ/配置で定量化されているか？ [明確性]」
- 「ホバー状態の要件は、すべてのインタラクティブ要素で一貫しているか？ [一貫性]」
- 「キーボード操作の要件はすべてのインタラクティブUIに対して定義されているか？ [網羅性]」
- 「ロゴ画像の読み込みに失敗したときのフォールバック動作は指定されているか？ [エッジケース]」
- 「非同期エピソードデータのロード状態は定義されているか？ [完全性]」
- 「競合するUI要素の視覚的階層を仕様で定義しているか？ [明確性]」

**項目構造**:
各項目は以下のパターンに従うべきです：
- 要件品質について尋ねる質問形式
- spec/plan に**書かれていること**（または書かれていないこと）に焦点を当てる
- ブラケット内に品質次元を含める [Completeness/Clarity/Consistency/etc.]
- 既存の要件を確認する場合は spec のセクション `[Spec §X.Y]` を参照する
- 欠落している要件を確認する場合は `[Gap]` マーカーを使用する

**品質次元別の例**:

**Completeness (完全性)**:
- 「すべてのAPI失敗モードについてエラー処理要件が定義されているか？ [Gap]」
- 「すべてのインタラクティブ要素についてアクセシビリティ要件が指定されているか？ [Completeness]」

**Clarity (明確性)**:
- 「『高速読み込み』は具体的なタイミング閾値で定量化されているか？ [Clarity, Spec §NFR-2]」
- 「『関連エピソード』の選択基準は明示的に定義されているか？ [Clarity, Spec §FR-5]」

**Consistency (一貫性)**:
- 「ナビゲーション要件はすべてのページで整合しているか？ [Consistency, Spec §FR-10]」

**Coverage (網羅性)**:
- 「ゼロ状態のシナリオ（エピソードなし）の要件は定義されているか？ [Coverage, Edge Case]」
- 「同時ユーザーインタラクションのシナリオは扱われているか？ [Coverage, Gap]」

**Measurability (測定可能性)**:
- 「視覚的階層の要件は測定/テスト可能か？ [Acceptance Criteria, Spec §FR-1]」

**トレーサビリティ要件**:
- 最低限：項目の80%以上に少なくとも1つのトレーサビリティ参照を含めること
- 各項目は次を参照すること：specセクション `[Spec §X.Y]`、またはマーカー `[Gap]`, `[Ambiguity]`, `[Conflict]`, `[Assumption]`

**🚫 絶対に禁止** - これらは要件テストではなく実装テストになります：
- ❌ 「検証する」「テストする」「確認する」「チェックする」+ 実装の動作で始まる項目
- ❌ コード実行、ユーザーアクション、システム動作への言及
- ❌ 「正しく表示される」「適切に機能する」「期待通りに動作する」
- ❌ 「クリック」「ナビゲート」「レンダリング」「ロード」「実行」
- ❌ テストケース、テスト計画、QA手順
- ❌ 実装の詳細（フレームワーク、API、アルゴリズム）

**✅ 必須パターン** - これらは要件品質をテストします：
- ✅ 「[シナリオ]について[要件タイプ]は定義/指定/文書化されているか？」
- ✅ 「[曖昧な用語]は具体的な基準で定量化/明確化されているか？」
- ✅ 「要件は[セクションA]と[セクションB]の間で一貫しているか？」
- ✅ 「[要件]は客観的に測定/検証可能か？」

### 6. 構造参照

タイトル、メタセクション、カテゴリ見出し、IDフォーマットについては、`.specify/templates/checklist-template.md` 内の標準テンプレートに従ってチェックリストを生成します。テンプレートが利用できない場合は、次を使用します：H1タイトル、目的/作成メタ行、`##` カテゴリセクション（`- [ ] CHK### <要件項目>` という行を含み、CHK001からグローバルに増分するIDを持つ）。

### 7. レポート

作成されたチェックリストへのフルパス、項目数を出力し、実行ごとに新しいファイルが作成されることをユーザーに通知します。以下を要約します：
- 選択されたフォーカス領域
- 深さレベル
- アクター/タイミング
- 組み込まれたユーザー指定の必須項目

**重要**: 各 `/speckit.checklist` コマンド呼び出しは、ファイルが既に存在しない限り、短く説明的な名前を使用して新しいチェックリストファイルを作成します。これにより以下が可能になります：
- 異なるタイプの複数のチェックリスト（例：`ux.md`, `test.md`, `security.md`）
- チェックリストの目的を示すシンプルで覚えやすいファイル名
- `checklists/` フォルダ内での容易な識別とナビゲーション

**禁止事項**:
- ❌ 実装テストの記述（Anti-Examplesを参照）
- ❌ コードやシステム動作への言及
