# 機能仕様書: MappingEngineリファクタリング

**機能ブランチ**: `010-mapping-engine-refactoring`
**作成日**: 2026-02-05
**ステータス**: ドラフト
**入力**: Gemini CLIによるコードベース分析結果

## 背景

`MappingEngine.ts` は現在1000行を超えるモノリシックなファイルであり、以下の問題を抱えている:
- すべての変換ロジックが単一ファイルに集中
- `new Function()` によるセキュリティリスク（XSS、任意コード実行）
- テストと保守が困難
- 新しい変換タイプの追加が複雑

## ユーザーシナリオとテスト

### ユーザーストーリー 1 - Strategyパターン導入 (優先度: P1)

開発者として、変換ロジックがStrategyパターンで整理されていることで、各変換タイプを独立して理解・修正・テストできるようにしたい。

**この優先度の理由**: コードの保守性とテスト容易性が大幅に向上し、将来の機能追加の基盤となる。

**独立テスト**: 各変換Strategyクラスが独立したユニットテストで検証でき、既存のMappingEngine.test.tsのテストがすべてパスする。

**受け入れシナリオ**:

1. **前提条件** 既存のMappingEngineテストが存在する, **操作** リファクタリング後にnpm testを実行, **期待結果** すべての既存テストがパスする
2. **前提条件** 新しいStrategyクラス構造, **操作** Sourceトランスフォーメーションを実行, **期待結果** 従来と同じ結果が得られる
3. **前提条件** 21種類以上の変換タイプ, **操作** 各変換を個別にテスト, **期待結果** 各変換が独立して動作する

---

### ユーザーストーリー 2 - セキュアな式評価 (優先度: P1)

セキュリティ担当として、`new Function()` の使用を排除し、安全な式評価メカニズムを導入したい。

**この優先度の理由**: セキュリティリスクの排除は必須。任意コード実行の脆弱性は深刻。

**独立テスト**: 式評価のセキュリティテストを追加し、悪意のある入力がブロックされることを確認する。

**受け入れシナリオ**:

1. **前提条件** 式評価機能, **操作** 正当な式（例: `field1 + field2`）を評価, **期待結果** 正しい結果が返る
2. **前提条件** 式評価機能, **操作** 悪意のある式（例: `process.exit(1)`）を評価, **期待結果** エラーまたは安全な失敗
3. **前提条件** ExpressionFunctions.tsの関数, **操作** IIF、CONCAT等の組み込み関数を使用, **期待結果** 正しく動作する

---

### ユーザーストーリー 3 - ファイル分割と整理 (優先度: P2)

開発者として、変換ロジックが適切なファイルに分割されていることで、コードナビゲーションとレビューが容易になることを期待する。

**この優先度の理由**: 保守性向上には重要だが、機能的には影響しない。

**独立テスト**: ファイル構造の変更後もすべてのテストがパスし、インポートパスが正しく機能する。

**受け入れシナリオ**:

1. **前提条件** 分割後のファイル構造, **操作** npm run build, **期待結果** ビルドが成功する
2. **前提条件** 各変換タイプのファイル, **操作** 特定の変換タイプのコードを探す, **期待結果** 対応するファイルで見つかる

---

### エッジケース

- 複雑なネスト式（例: `IIF(A > B, CONCAT(C, D), E)`）の評価
- 循環参照を含む式
- 非常に長い式文字列
- 存在しないフィールド参照

## 要件

### 機能要件

- **FR-001**: システムは各変換タイプに対して独立したStrategyクラスを提供しなければならない
- **FR-002**: システムは`new Function()`を使用せず式を安全に評価しなければならない
- **FR-003**: 変換Strategyは`src/lib/transformations/`ディレクトリに格納されなければならない
- **FR-004**: TransformationStrategyインターフェースを定義し、すべての変換が実装しなければならない
- **FR-005**: MappingEngine.tsはStrategy選択とオーケストレーションのみを担当しなければならない
- **FR-006**: 既存のすべての変換タイプ（21種類以上）が引き続き動作しなければならない

### 主要エンティティ

- **TransformationStrategy**: 各変換タイプが実装するインターフェース（execute, validate等のメソッド）
- **TransformationContext**: 変換実行に必要なコンテキスト情報（入力データ、設定、ルックアップキャッシュ等）
- **SafeExpressionEvaluator**: セキュアな式評価を行うクラス

## 成功基準

### 測定可能なアウトカム

- **SC-001**: MappingEngine.tsのコード行数が500行以下になる
- **SC-002**: すべての既存テスト（MappingEngine.test.ts）がパスする
- **SC-003**: `new Function()`の使用がコードベースから排除される
- **SC-004**: 新しい変換タイプの追加が単一ファイルの作成で完結する
- **SC-005**: 各変換Strategyが独立したユニットテストを持つ

## 技術的考慮事項

### 推奨アプローチ

1. **式評価**:
   - 許可リスト方式の演算子・関数のみサポート
   - または軽量な式パーサーライブラリの導入（例: expr-eval）

2. **Strategyパターン**:
   ```typescript
   interface TransformationStrategy {
     type: TransformationType;
     execute(context: TransformationContext): TransformationResult;
     validate(config: TransformationConfig): ValidationResult;
   }
   ```

3. **ディレクトリ構造**:
   ```
   src/lib/
   ├── MappingEngine.ts          # オーケストレーター（軽量化）
   ├── MappingTypes.ts           # 型定義（既存）
   ├── SafeExpressionEvaluator.ts # セキュアな式評価
   └── transformations/
       ├── index.ts              # Strategy登録
       ├── SourceStrategy.ts
       ├── TargetStrategy.ts
       ├── FilterStrategy.ts
       ├── JoinerStrategy.ts
       ├── LookupStrategy.ts
       └── ...（各変換タイプ）
   ```
