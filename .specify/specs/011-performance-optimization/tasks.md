# タスク: パフォーマンス最適化

**入力**: `/specs/011-performance-optimization/` からの設計ドキュメント
**前提条件**: spec.md

## フォーマット: `[ID] [P?] [Story] 説明`

- **[P]**: 並行実行可能（異なるファイル、依存関係なし）
- **[Story]**: このタスクが属するユーザーストーリー（US1, US2, US3）

---

## フェーズ 1: セットアップ（分析と計測基盤）

**目的**: 現状のパフォーマンスを計測し、改善効果を測定できる状態にする

- [x] T001 [P] PipelineFlow.tsx の現状レンダリング回数を React DevTools で測定・記録
- [x] T002 [P] JobMonitor.tsx の現状レンダリング回数を React DevTools で測定・記録
- [x] T003 [P] VirtualDB.tsx の大量データ（10000レコード）挿入時のパフォーマンスを測定・記録

**チェックポイント**: ベースラインが確立され、改善効果を定量的に測定可能

---

## フェーズ 2: ユーザーストーリー 1 - PipelineFlowレイアウト最適化 (優先度: P1)

**ゴール**: dagreレイアウト計算をメモ化し、不要な再計算を排除

**独立テスト**: ノード/エッジ変更時のみレイアウト再計算が発生することをReact DevToolsで確認

### 実装

- [x] T004 [US1] `src/lib/hooks/usePipelineLayout.ts` を作成（dagreレイアウト計算のカスタムフック）
- [x] T005 [US1] usePipelineLayout にノード/エッジの浅い比較ロジックを実装
- [x] T006 [US1] PipelineFlow.tsx を usePipelineLayout を使用するよう更新
- [x] T007 [US1] PipelineFlow.tsx の依存配列を最適化（不要な依存を削除）
- [x] T008 [US1] usePipelineLayout のユニットテストを作成

### 検証

- [x] T009 [US1] React DevTools で改善後のレンダリング回数を測定・記録
- [x] T010 [US1] 50ノードのパイプラインでフレームレートを測定

**チェックポイント**: PipelineFlowの不要なレイアウト再計算が排除される

---

## フェーズ 3: ユーザーストーリー 2 - JobMonitor再レンダリング最適化 (優先度: P1)

**ゴール**: 時間表示を分離し、ジョブリスト全体の再レンダリングを防止

**独立テスト**: 時間更新時に ElapsedTimeDisplay のみが再レンダリングされることを確認

### 実装

- [x] T011 [US2] `src/components/common/ElapsedTimeDisplay.tsx` を作成（React.memo使用）
- [x] T012 [US2] ElapsedTimeDisplay に独自の時間更新ロジックを実装（useState + setInterval）
- [x] T013 [US2] JobMonitor.tsx で ElapsedTimeDisplay を使用するよう更新
- [x] T014 [US2] ジョブ行コンポーネントを React.memo でラップ
- [x] T015 [US2] モーダル内のログリストも最適化（仮想化または制限）

### 検証

- [x] T016 [US2] React DevTools で改善後のレンダリング回数を測定・記録
- [x] T017 [US2] 100件のジョブログで時間更新時のパフォーマンスを確認

**チェックポイント**: JobMonitorの不要な再レンダリングが排除される

---

## フェーズ 4: ユーザーストーリー 3 - VirtualDBメモリ効率改善 (優先度: P2)

**ゴール**: 大量データを効率的に処理し、メモリ使用量を制限

**独立テスト**: 10000レコード挿入後もクエリ応答が100ms以下

### 実装

- [x] T018 [US3] VirtualDB に設定可能なレコード上限オプションを追加
- [x] T019 [US3] LRU方式のレコードパージロジックを実装
- [x] T020 [US3] レコード数が上限に達した場合の警告ログを追加
- [x] T021 [US3] VirtualDB のパフォーマンステストを作成

### 検証

- [x] T022 [US3] 10000レコード挿入時のメモリ使用量を測定
- [x] T023 [US3] LRUパージが正しく動作することを確認

**チェックポイント**: VirtualDBのメモリ管理が改善される

---

## フェーズ 5: ポリッシュと最終検証

**目的**: 全体的な検証と文書化

- [x] T024 [P] 各コンポーネントのパフォーマンス改善をまとめた比較レポートを作成
- [x] T025 npm test && npm run build で最終検証
- [x] T026 実際のシミュレーション実行でパフォーマンスを体感確認
- [x] T027 [P] 新規追加ファイルに日本語コメントを追加

---

## 依存関係と実行順序

### フェーズの依存関係

- **セットアップ (フェーズ 1)**: 依存関係なし - すべてのタスク並行実行可能
- **US1 PipelineFlow (フェーズ 2)**: フェーズ 1 完了後に開始
- **US2 JobMonitor (フェーズ 3)**: フェーズ 1 完了後に開始、フェーズ 2 と並行可能
- **US3 VirtualDB (フェーズ 4)**: フェーズ 1 完了後に開始、フェーズ 2, 3 と並行可能
- **ポリッシュ (フェーズ 5)**: フェーズ 2, 3, 4 完了後

### ユーザーストーリー間の並行実行

- US1, US2, US3 は互いに独立しており、同時に作業可能
- 各ストーリー内では依存関係に従って順次実行

### 並行実行の機会

- T001, T002, T003 は並行実行可能（計測タスク）
- T024, T027 は並行実行可能（文書化タスク）
- フェーズ 2, 3, 4 は異なる開発者が並行作業可能

---

## 注記

- パフォーマンス改善の効果は必ず定量的に測定・記録する
- React DevTools の Profiler を使用してレンダリング回数と時間を計測
- 最適化によって既存のテストが失敗しないことを各ステップで確認
- useMemo/useCallback の過剰使用は避け、実際に効果がある箇所のみに適用
