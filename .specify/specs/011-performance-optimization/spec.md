# 機能仕様書: パフォーマンス最適化

**機能ブランチ**: `011-performance-optimization`
**作成日**: 2026-02-05
**ステータス**: 完了
**入力**: Gemini CLIによるコードベース分析結果

## 背景

コードベース分析により、以下のパフォーマンス問題が特定された:

1. **PipelineFlow.tsx**: 毎レンダリングでdagreレイアウト計算を実行
2. **JobMonitor.tsx**: 毎秒の時間更新で全リストが再レンダリング
3. **VirtualDB.tsx**: 全データをメモリ上の配列で管理（大規模データで問題）
4. **シミュレーションループ**: 最適化の余地あり

## ユーザーシナリオとテスト

### ユーザーストーリー 1 - PipelineFlowレイアウト最適化 (優先度: P1)

ユーザーとして、パイプライン可視化がスムーズに動作し、ノードの追加・削除時にのみレイアウト再計算が行われることを期待する。

**この優先度の理由**: PipelineFlowはメインの可視化コンポーネントであり、パフォーマンス問題が最も顕著に現れる。

**独立テスト**: パイプラインにノードを追加/削除した場合にのみレイアウトが再計算されることをReact DevToolsで確認できる。

**受け入れシナリオ**:

1. **前提条件** パイプライン表示中, **操作** シミュレーションを実行, **期待結果** レイアウト計算が不必要に繰り返されない
2. **前提条件** 10個以上のノードを持つパイプライン, **操作** ノードを1つ追加, **期待結果** スムーズにレイアウトが更新される
3. **前提条件** パイプライン表示中, **操作** パイプライン設定を変更せずに他の設定を変更, **期待結果** レイアウト再計算が発生しない

---

### ユーザーストーリー 2 - JobMonitor再レンダリング最適化 (優先度: P1)

ユーザーとして、ジョブモニターで経過時間が更新されても、ジョブリスト全体が再レンダリングされないことを期待する。

**この優先度の理由**: JobMonitorは頻繁に使用され、毎秒の更新による再レンダリングはパフォーマンスに直接影響。

**独立テスト**: React DevToolsでJobMonitor使用中のレンダリング回数を測定し、時間更新が個別コンポーネントに限定されることを確認。

**受け入れシナリオ**:

1. **前提条件** 複数のジョブが実行中, **操作** 1秒経過, **期待結果** 時間表示コンポーネントのみ再レンダリング
2. **前提条件** 100件のジョブログ表示, **操作** 経過時間の更新, **期待結果** ログリスト全体の再レンダリングなし
3. **前提条件** ジョブモニターを開いた状態, **操作** 新しいジョブが追加, **期待結果** 新しい行のみが追加される

---

### ユーザーストーリー 3 - VirtualDBメモリ効率改善 (優先度: P2)

開発者として、VirtualDBが大量のデータを効率的に処理できるよう、メモリ管理が改善されていることを期待する。

**この優先度の理由**: シミュレーション中に大量のレコードが生成される場合に重要だが、通常の使用では顕著な問題にならない可能性がある。

**独立テスト**: 10000レコード以上のテーブルでクエリ実行時間を測定し、許容範囲内であることを確認。

**受け入れシナリオ**:

1. **前提条件** 空のVirtualDB, **操作** 10000レコードを挿入, **期待結果** メモリ使用量が線形に増加
2. **前提条件** 大量データのテーブル, **操作** レコード数の制限に達した, **期待結果** 古いレコードが自動的にパージされる（LRU）
3. **前提条件** VirtualDB使用中, **操作** ブラウザのメモリプロファイラで確認, **期待結果** メモリリークがない

---

### エッジケース

- 非常に複雑なパイプライン（50ノード以上）でのレイアウト計算
- 高速でジョブが追加される場合のJobMonitor動作
- ブラウザのメモリ制限に近い状態でのVirtualDB動作
- シミュレーション速度を最大にした場合のパフォーマンス

## 要件

### 機能要件

- **FR-001**: PipelineFlow.tsxはノード/エッジの変更時のみdagreレイアウトを再計算しなければならない
- **FR-002**: レイアウト計算ロジックをカスタムフック `usePipelineLayout` に抽出しなければならない
- **FR-003**: JobMonitor.tsxの時間表示は独立したコンポーネント（ElapsedTime等）に分離しなければならない
- **FR-004**: ジョブリストはReact.memoで不要な再レンダリングを防止しなければならない
- **FR-005**: VirtualDBは設定可能なレコード数上限を持ち、超過時はLRU方式でパージしなければならない
- **FR-006**: すべての最適化は既存の機能を壊してはならない

### 主要エンティティ

- **usePipelineLayout**: dagreレイアウト計算をメモ化するカスタムフック
- **ElapsedTimeDisplay**: 経過時間表示専用コンポーネント（独立した再レンダリング）
- **VirtualDBConfig**: レコード上限等の設定オプション

## 成功基準

### 測定可能なアウトカム

- **SC-001**: PipelineFlow.tsxのレイアウト計算がノード/エッジ変更時のみ発生する（React DevToolsで確認）
- **SC-002**: JobMonitorで時間更新時の再レンダリング数が現行の10%以下になる
- **SC-003**: 50ノードのパイプラインでフレームレートが30fps以上を維持する
- **SC-004**: VirtualDBに10000レコード挿入後もクエリ応答が100ms以下
- **SC-005**: npm test && npm run build がすべてパスする

## 技術的考慮事項

### PipelineFlow最適化

```typescript
// usePipelineLayout.ts
export function usePipelineLayout(nodes: Node[], edges: Edge[]) {
  return useMemo(() => {
    // dagreレイアウト計算
    return calculateLayout(nodes, edges);
  }, [nodes, edges]); // 依存配列を最小限に
}
```

### JobMonitor最適化

```typescript
// ElapsedTimeDisplay.tsx
const ElapsedTimeDisplay = React.memo(({ startTime }: { startTime: number }) => {
  const [elapsed, setElapsed] = useState(0);
  useEffect(() => {
    const interval = setInterval(() => setElapsed(Date.now() - startTime), 1000);
    return () => clearInterval(interval);
  }, [startTime]);
  return <span>{formatDuration(elapsed)}</span>;
});
```

### VirtualDBメモリ管理

- LRUキャッシュの導入を検討
- 設定可能なレコード上限（デフォルト: 10000レコード/テーブル）
- 将来的にはIndexedDBへの移行も検討（ただし本仕様のスコープ外）
